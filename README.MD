# Описание
Пример использования CGO для вызова кода на C из Go. Плюсовый проект состоит из двух библиотек:
- `track-filter` — «сложная» плюсовая библиотека. Никаким образом не зависит от Go и живет сама по себе и компилируется в `libtrack_filter.a`.
- `go_bridge` — сишная обертка над `track-filter`, которая позволяет вызывать её из Go. Компилируется в статическую библиотеку `libgo_bridge.a`, которая линкуется с Go-программой.

Для сборки проекта используется docker-compose. Чтобы собрать проект и запустить гошные тесты, из корня необходимо выполнить команду:
```sh
docker compose up -d
```
Если команда отработала успешно, будет создан контйенер с именем `dev-1` и все тесты прошли. Чтобы зайти внутрь контейнера, нужно скопировать его id и выполнить команду:
```sh
docker exec -it <container_id> sh
```

## Запуск go-тестов руками
Для проверки корректности передачи данных Go->C и C->Go нужно писать тесты. Пример тестов в go_tests/bridge_test.go. Для запуска тестов локально нужно перейти в директорию с тестами и выполнить команду ниже.
```sh
go test
```

## Возможные ошибки
- Не копируйте в контейнер папки со сборкой


### Линковка с плюсами «вручную»

Скомпилировать плюсы в статическую библиотеку. Перед компиляцией удостовериться, что утилиты `ranlib` и `ar` из пакета `binutils` находятся в `$PATH` перед системными утилитами.
```sh
❯ which -a ranlib
/usr/bin/ranlib
/usr/local/opt/binutils/bin/ranlib

❯ which -a ar
/usr/bin/ar
/usr/local/opt/binutils/bin/ar
```


```sh
gcc -c example.c
ar rcs libexample.a example.o
```

Указать путь к статической библиотеке в секции cgo LDFLAGS. 

## Поставка библиотеки
Вместо указания путей к библиотекам в секции cgo LDFLAGS можно поставить библиотеку в системную директорию и указать только её имя. Как правило системными считаются директории `/usr/lib`, `/usr/local/lib`, `/lib`. Нужно уточнять у клиента, куда он хочет поставить библиотеку.

То же относится и к хедерам. Их можно положить в директорию `/usr/include` или `/usr/local/include`.
