# Описание
Пример использования CGO для вызова кода на C из Go. Плюсовый проект состоит из двух библиотек:
- `track-filter` — «сложная» плюсовая библиотека. Никаким образом не зависит от Go и живет сама по себе и компилируется в `libtrack_filter.a`.
- `go_bridge` — сишная обертка над `track-filter`, которая позволяет вызывать её из Go. Компилируется в статическую библиотеку `libgo_bridge.a`, которая линкуется с Go-программой.

Для сборки проекта используется docker-compose. Чтобы собрать проект из корня проетка необходимо выполнить команду:
```sh
docker compose up -d
```
Если команда отработала успешно, будет создан контйенер с именем `dev-1`. Можно зайти внутрь него и запустить гошный код, который вызывает плюсовую функцию через C-слой. Для этого нужно скопировать id контейнера и выполнить команду:
```sh
docker exec -it <container_id> sh
cd go_main
./main
```

## Запуск go-тестов
Для проверки корректности передачи данных Go->C и C->Go нужно писать тесты. Пример тестов в go_main/main_test.go. Для запуска тестов локально нужно перейти в директорию с тестами и выполнить команду ниже.
```sh
go test
```

## Возможные ошибки
- Не копируйте в контейнер папки со сборкой


## Необязательные интересности
### Линковка с плюсами «вручную»

Скомпилировать плюсы в статическую библиотеку. Перед компиляцией удостовериться, что утилиты `ranlib` и `ar` из пакета `binutils` находятся в `$PATH` перед системными утилитами.
```sh
❯ which -a ranlib
/usr/bin/ranlib
/usr/local/opt/binutils/bin/ranlib

❯ which -a ar
/usr/bin/ar
/usr/local/opt/binutils/bin/ar
```


```sh
gcc -c example.c
ar rcs libexample.a example.o
```

Указать путь к статической библиотеке в секции cgo LDFLAGS. 
